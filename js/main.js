// Generated by CoffeeScript 1.6.3
var SCREEN_HEIGHT, SCREEN_WIDTH, STARTX, animDelta, animDeltaDir, animate, animateTerrain, applyShader, camera, cameraOrtho, checkhit, clock, composer, container, controls, cursorPosition, directionalLight, gameover, heightMap, increaseScores, increaseSpeed, init, lightDir, lightVal, loadTextures, mlib, morph, morphs, normalMap, oldSoundVal, oldSpeed, onTouchEnd, onTouchMove, onTouchStart, onWindowResize, play, pointLight, quadTarget, record, render, renderer, riverBlock, riverPosition, scene, sceneRenderTarget, scores, scoresTimeout, setRiverPosition, soundDir, soundVal, soundtrack, speed, speedTimeout, started, statics, stats, stopTimeout, terrain, textMesh1, textureCounter, uniformsNoise, uniformsNormal, uniformsTerrain, updateNoise, updateRiverPosition, waterMesh;

sceneRenderTarget = void 0;

SCREEN_WIDTH = window.innerWidth;

SCREEN_HEIGHT = window.innerHeight;

STARTX = -3000;

renderer = void 0;

container = void 0;

stats = void 0;

camera = void 0;

scene = void 0;

cameraOrtho = void 0;

sceneRenderTarget = void 0;

uniformsNoise = void 0;

uniformsNormal = void 0;

heightMap = void 0;

normalMap = void 0;

quadTarget = void 0;

directionalLight = void 0;

pointLight = void 0;

terrain = void 0;

textureCounter = 0;

animDelta = 0;

animDeltaDir = -1;

lightVal = 0;

lightDir = 1;

soundVal = 0;

oldSoundVal = 0;

soundDir = 1;

clock = new THREE.Clock();

morph = void 0;

morphs = [];

statics = [];

updateNoise = true;

animateTerrain = false;

textMesh1 = void 0;

mlib = {};

cursorPosition = 0;

riverPosition = 0;

record = 0;

oldSpeed = 0;

speed = 1;

speedTimeout = 0;

controls = void 0;

uniformsTerrain = void 0;

composer = void 0;

stopTimeout = 0;

waterMesh = void 0;

scores = 0;

scoresTimeout = 0;

started = false;

soundtrack = void 0;

riverBlock = document.getElementById('river');

updateRiverPosition = function(pos) {
  riverPosition = pos;
  return riverBlock.style.left = -150 + SCREEN_WIDTH * (riverPosition + 1) / 2 + "px";
};

setRiverPosition = function(delta) {
  if (Math.abs(cursorPosition - riverPosition) < 0.01) {
    return;
  }
  if (riverPosition > cursorPosition) {
    return updateRiverPosition(riverPosition - 0.5 * delta);
  } else {
    return updateRiverPosition(riverPosition + 0.5 * delta);
  }
};

checkhit = function(position) {
  var nposition;
  nposition = position / 1000;
  if (Math.abs(nposition - riverPosition) < 0.4) {
    return gameover();
  }
};

increaseSpeed = function() {
  speed = Math.max(1, Math.min(speed * 1.25, 10));
  if (speed < 10) {
    return speedTimeout = setTimeout(increaseSpeed, Math.ceil(speed * 1000));
  }
};

increaseScores = function() {
  scores += Math.floor(speed);
  document.getElementById('scores').innerHTML = scores.toString();
  return scoresTimeout = setTimeout(increaseScores, 100);
};

play = function() {
  scores = 0;
  oldSpeed = 0;
  clearTimeout(stopTimeout);
  clearTimeout(speedTimeout);
  increaseSpeed();
  clearTimeout(scoresTimeout);
  increaseScores();
  soundtrack.position = 0;
  soundtrack.play();
  lightDir = 1;
  started = true;
  document.getElementById('start').style.display = 'none';
  document.getElementById('help').style.display = "flex";
  setTimeout((function() {
    return document.getElementById('help').style.opacity = "0.0";
  }), 0);
  document.getElementById('info').style.display = 'block';
  document.getElementById('river').style.display = 'block';
  return document.getElementById('river').style.opacity = 0.75;
};

gameover = function() {
  clearTimeout(speedTimeout);
  clearTimeout(scoresTimeout);
  oldSpeed = 0;
  speed = 1;
  record = Math.max(scores, record);
  scores = 0;
  lightDir = -1;
  document.getElementById('river').style.opacity = 0.0;
  document.getElementById('record').innerHTML = record;
  document.getElementById('start').style.display = 'flex';
  document.getElementById('start').innerHTML = "Game Over";
  stopTimeout = setTimeout((function() {
    soundtrack.pause();
    return document.getElementById('start').innerHTML = "Touch to Start";
  }), 2500);
  document.getElementById('help').style.display = "none";
  document.getElementById('help').style.opacity = "1.0";
  return document.getElementById('info').style.display = 'none';
};

onTouchStart = function(event) {
  if (event.touches.length === 1) {
    return cursorPosition = 2 * event.changedTouches[0].pageX / SCREEN_WIDTH - 1.0;
  }
};

onTouchMove = function(event) {
  if (event.touches.length === 1) {
    return cursorPosition = 2 * event.changedTouches[0].pageX / SCREEN_WIDTH - 1.0;
  }
};

onTouchEnd = function(event) {};

onWindowResize = function(event) {
  SCREEN_WIDTH = window.innerWidth;
  SCREEN_HEIGHT = window.innerHeight;
  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
  camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
  return camera.updateProjectionMatrix();
};

loadTextures = function() {
  textureCounter += 1;
  if (textureCounter === 3) {
    terrain.visible = true;
    document.getElementById("loading").style.display = "none";
    return document.getElementById("start").style.display = "flex";
  }
};

applyShader = function(shader, texture, target) {
  var meshTmp, sceneTmp, shaderMaterial;
  shaderMaterial = new THREE.ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: THREE.UniformsUtils.clone(shader.uniforms)
  });
  shaderMaterial.uniforms["tDiffuse"].value = texture;
  sceneTmp = new THREE.Scene();
  meshTmp = new THREE.Mesh(new THREE.PlaneGeometry(SCREEN_WIDTH, SCREEN_HEIGHT), shaderMaterial);
  meshTmp.position.z = -500;
  sceneTmp.add(meshTmp);
  return renderer.render(sceneTmp, cameraOrtho, target, true);
};

init = function() {
  var addMorph, addStatic, bluriness, detailTexture, diffuseTexture1, diffuseTexture2, effectBleach, effectBloom, geometryTerrain, hblur, i, loader, material, morphColorsToFaceColors, normalShader, params, pars, plane, renderModel, renderTarget, renderTargetParameters, rx, ry, specularMap, terrainShader, vblur, vertexShader;
  container = document.getElementById('container');
  soundtrack = document.getElementById('soundtrack');
  soundtrack.pause();
  sceneRenderTarget = new THREE.Scene();
  cameraOrtho = new THREE.OrthographicCamera(SCREEN_WIDTH / -2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / -2, -20000, 20000);
  cameraOrtho.position.z = 500;
  sceneRenderTarget.add(cameraOrtho);
  camera = new THREE.PerspectiveCamera(80, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 4000);
  camera.position.set(-1024, 512, 0);
  controls = new THREE.TrackballControls(camera);
  controls.target.set(0, 0, 0);
  controls.rotateSpeed = 1.0;
  controls.noZoom = true;
  controls.noPan = true;
  controls.noRoll = true;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.15;
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x050505, 2000, 4000);
  directionalLight = new THREE.DirectionalLight(0xffffff, 1.15);
  directionalLight.position.set(500, 2000, 0);
  pointLight = new THREE.PointLight(0xff4400, 1.5);
  pointLight.position.set(0, 0, 0);
  scene.add(directionalLight);
  scene.add(pointLight);
  normalShader = THREE.NormalMapShader;
  rx = 256;
  ry = 256;
  pars = {
    minFilter: THREE.LinearMipmapLinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBFormat
  };
  heightMap = new THREE.WebGLRenderTarget(rx, ry, pars);
  normalMap = new THREE.WebGLRenderTarget(rx, ry, pars);
  uniformsNoise = {
    time: {
      type: "f",
      value: 1.0
    },
    scale: {
      type: "v2",
      value: new THREE.Vector2(1.5, 1.5)
    },
    offset: {
      type: "v2",
      value: new THREE.Vector2(0, 0)
    }
  };
  uniformsNormal = THREE.UniformsUtils.clone(normalShader.uniforms);
  uniformsNormal.height.value = 0.05;
  uniformsNormal.resolution.value.set(rx, ry);
  uniformsNormal.heightMap.value = heightMap;
  vertexShader = document.getElementById("vertexShader").textContent;
  specularMap = new THREE.WebGLRenderTarget(2048, 2048, pars);
  diffuseTexture1 = THREE.ImageUtils.loadTexture("images/textures/grasslight-big.jpg", null, function() {
    loadTextures();
    return applyShader(THREE.LuminosityShader, diffuseTexture1, specularMap);
  });
  diffuseTexture2 = THREE.ImageUtils.loadTexture("images/textures/backgrounddetailed6.jpg", null, loadTextures);
  detailTexture = THREE.ImageUtils.loadTexture("images/textures/grasslight-big-nm.jpg", null, loadTextures);
  diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
  diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
  detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
  specularMap.wrapS = specularMap.wrapT = THREE.RepeatWrapping;
  terrainShader = THREE.ShaderTerrain["terrain"];
  uniformsTerrain = THREE.UniformsUtils.clone(terrainShader.uniforms);
  uniformsTerrain["tNormal"].value = normalMap;
  uniformsTerrain["uNormalScale"].value = 3.5;
  uniformsTerrain["tDisplacement"].value = heightMap;
  uniformsTerrain["tDiffuse1"].value = diffuseTexture1;
  uniformsTerrain["tDiffuse2"].value = diffuseTexture2;
  uniformsTerrain["tSpecular"].value = specularMap;
  uniformsTerrain["tDetail"].value = detailTexture;
  uniformsTerrain["enableDiffuse1"].value = true;
  uniformsTerrain["enableDiffuse2"].value = true;
  uniformsTerrain["enableSpecular"].value = true;
  uniformsTerrain["uDiffuseColor"].value.setHex(0xffffff);
  uniformsTerrain["uSpecularColor"].value.setHex(0xffffff);
  uniformsTerrain["uAmbientColor"].value.setHex(0x111111);
  uniformsTerrain["uShininess"].value = 30;
  uniformsTerrain["uDisplacementScale"].value = 175;
  uniformsTerrain["uRepeatOverlay"].value.set(6, 6);
  params = [["heightmap", document.getElementById("fragmentShaderNoise").textContent, vertexShader, uniformsNoise, false], ["normal", normalShader.fragmentShader, normalShader.vertexShader, uniformsNormal, false], ["terrain", terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true]];
  i = 0;
  while (i < params.length) {
    material = new THREE.ShaderMaterial({
      uniforms: params[i][3],
      vertexShader: params[i][2],
      fragmentShader: params[i][1],
      lights: params[i][4],
      fog: true
    });
    mlib[params[i][0]] = material;
    i++;
  }
  plane = new THREE.PlaneGeometry(SCREEN_WIDTH, SCREEN_HEIGHT);
  quadTarget = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({
    color: 0x000000
  }));
  quadTarget.position.z = -500;
  sceneRenderTarget.add(quadTarget);
  geometryTerrain = new THREE.PlaneGeometry(6000, 6000, 256, 256);
  geometryTerrain.computeFaceNormals();
  geometryTerrain.computeVertexNormals();
  geometryTerrain.computeTangents();
  terrain = new THREE.Mesh(geometryTerrain, mlib["terrain"]);
  terrain.position.set(0, -125, 0);
  terrain.rotation.x = -Math.PI / 2;
  terrain.visible = false;
  scene.add(terrain);
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
  renderer.setClearColor(scene.fog.color, 1);
  renderer.domElement.style.position = "absolute";
  renderer.domElement.style.top = "0px";
  renderer.domElement.style.left = "0px";
  container.appendChild(renderer.domElement);
  renderer.gammaInput = true;
  renderer.gammaOutput = true;
  onWindowResize();
  window.addEventListener('resize', onWindowResize, false);
  document.addEventListener('touchstart', onTouchStart, false);
  document.addEventListener('touchmove', onTouchMove, false);
  document.addEventListener('touchend', onTouchEnd, false);
  renderer.autoClear = false;
  renderTargetParameters = {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBFormat,
    stencilBufer: false
  };
  renderTarget = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters);
  effectBloom = new THREE.BloomPass(0.6);
  effectBleach = new THREE.ShaderPass(THREE.BleachBypassShader);
  hblur = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader);
  vblur = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);
  bluriness = 2;
  hblur.uniforms["h"].value = bluriness / SCREEN_WIDTH;
  vblur.uniforms["v"].value = bluriness / SCREEN_HEIGHT;
  hblur.uniforms["r"].value = vblur.uniforms["r"].value = 0.5;
  effectBleach.uniforms["opacity"].value = 0.65;
  renderModel = new THREE.RenderPass(scene, camera);
  vblur.renderToScreen = true;
  composer = new THREE.EffectComposer(renderer, renderTarget);
  composer.addPass(renderModel);
  composer.addPass(effectBloom);
  composer.addPass(hblur);
  composer.addPass(vblur);
  addMorph = function(geometry, speed, duration, x, y, z) {
    var meshAnim;
    material = new THREE.MeshLambertMaterial({
      color: 0xffaa55,
      morphTargets: true,
      vertexColors: THREE.FaceColors
    });
    meshAnim = new THREE.MorphAnimMesh(geometry, material);
    meshAnim.speed = speed;
    meshAnim.duration = duration;
    meshAnim.time = 600 * Math.random();
    meshAnim.position.set(x, y, z);
    meshAnim.rotation.y = Math.PI / 2;
    meshAnim.castShadow = true;
    meshAnim.receiveShadow = false;
    scene.add(meshAnim);
    morphs.push(meshAnim);
    return renderer.initWebGLObjects(scene);
  };
  addStatic = function(geometry, materials, x, y, z) {
    var meshAnim;
    meshAnim = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
    meshAnim.speed = 250;
    meshAnim.duration = 500;
    meshAnim.time = 600 * Math.random();
    meshAnim.scale.set(4, 4, 4);
    meshAnim.position.set(x, y, z);
    meshAnim.rotation.y = Math.PI / 2 - z / 1500.0;
    meshAnim.castShadow = true;
    meshAnim.receiveShadow = false;
    meshAnim.start = x;
    meshAnim.checked = false;
    scene.add(meshAnim);
    statics.push(meshAnim);
    return renderer.initWebGLObjects(scene);
  };
  morphColorsToFaceColors = function(geometry) {
    var colorMap, _results;
    if (geometry.morphColors && geometry.morphColors.length) {
      colorMap = geometry.morphColors[0];
      i = 0;
    }
    _results = [];
    while (i < colorMap.colors.length) {
      geometry.faces[i].color = colorMap.colors[i];
      _results.push(i++);
    }
    return _results;
  };
  loader = new THREE.JSONLoader();
  loader.load("js/models/parrot.js", function(geometry) {
    morphColorsToFaceColors(geometry);
    addMorph(geometry, 250, 500, STARTX - 500, 500, 700);
    addMorph(geometry, 250, 500, STARTX - Math.random() * 500, 500, -200);
    addMorph(geometry, 250, 500, STARTX - Math.random() * 500, 500, 200);
    return addMorph(geometry, 250, 500, STARTX - Math.random() * 500, 500, 1000);
  });
  loader.load("js/models/flamingo.js", function(geometry) {
    morphColorsToFaceColors(geometry);
    return addMorph(geometry, 500, 1000, STARTX - Math.random() * 500, 350, 40);
  });
  loader.load("js/models/stork.js", function(geometry) {
    morphColorsToFaceColors(geometry);
    return addMorph(geometry, 350, 1000, STARTX - Math.random() * 500, 350, 340);
  });
  loader.load("js/models/buildings.js", function(geometry, materials) {
    var k, _i, _results;
    _results = [];
    for (k = _i = 0; _i <= 4; k = ++_i) {
      _results.push(addStatic(geometry, materials, -STARTX + 600 * k, -100, -1500 + Math.ceil(Math.random() * 3000)));
    }
    return _results;
  });
  return renderer.initWebGLObjects(scene);
};

render = function() {
  var delta, fHigh, fLow, stat, time, valNorm, _i, _j, _len, _len1;
  delta = clock.getDelta();
  setRiverPosition(delta);
  soundVal = THREE.Math.clamp(soundVal + delta * soundDir, 0, 1);
  if (speed !== oldSpeed) {
    soundtrack.playbackRate = 0.75 + (speed - 1) / 18.0;
    oldSpeed = speed;
  }
  if ((soundVal !== oldSoundVal) && soundtrack) {
    soundtrack.volume = soundVal;
    oldSoundVal = soundVal;
  }
  if (terrain.visible) {
    controls.update();
    time = Date.now() * 0.001;
    fLow = 0.1;
    fHigh = 0.8;
    lightVal = THREE.Math.clamp(lightVal + 0.5 * delta * lightDir, fLow, fHigh);
    valNorm = (lightVal - fLow) / (fHigh - fLow);
    scene.fog.color.setHSL(0.1, 0.5, lightVal);
    renderer.setClearColor(scene.fog.color, 1);
    directionalLight.intensity = THREE.Math.mapLinear(valNorm, 0, 1, 0.1, 1.15);
    pointLight.intensity = THREE.Math.mapLinear(valNorm, 0, 1, 0.9, 1.5);
    uniformsTerrain['uNormalScale'].value = THREE.Math.mapLinear(valNorm, 0, 1, 0.6, 3.5);
    if (updateNoise) {
      animDelta = THREE.Math.clamp(animDelta + 0.00075 * animDeltaDir, 0, 0.05);
      uniformsNoise["time"].value += delta * animDelta;
      uniformsNoise["offset"].value.x += delta * speed * 0.05;
      uniformsTerrain["uOffset"].value.x = 4 * uniformsNoise["offset"].value.x;
      quadTarget.material = mlib["heightmap"];
      renderer.render(sceneRenderTarget, cameraOrtho, heightMap, true);
      quadTarget.material = mlib["normal"];
      renderer.render(sceneRenderTarget, cameraOrtho, normalMap, true);
    }
    for (_i = 0, _len = statics.length; _i < _len; _i++) {
      stat = statics[_i];
      stat.position.x -= 180 * delta * speed;
      if (stat.position.x < -500 && !stat.checked) {
        if (started) {
          checkhit(stat.position.z);
        }
        stat.checked = true;
      }
      if (stat.position.x <= STARTX) {
        stat.checked = false;
        stat.position.x = stat.start;
        stat.position.z = -1500 + Math.ceil(Math.random() * 3000);
        stat.rotation.y = (Math.PI / 2) - (stat.position.z / 1500.0);
      }
    }
    for (_j = 0, _len1 = morphs.length; _j < _len1; _j++) {
      morph = morphs[_j];
      morph.updateAnimation(1000 * delta);
      morph.position.x += morph.speed * delta;
      if (morph.position.x > 2000) {
        morph.position.x = -1500 - Math.random() * 500;
      }
    }
    return composer.render(0.1);
  }
};

animate = function() {
  requestAnimationFrame(animate);
  return render();
};

init();

animate();

document.getElementById("start").onclick = play;
